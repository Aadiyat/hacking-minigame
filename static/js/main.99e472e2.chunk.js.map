{"version":3,"sources":["components/CurrentSelection.jsx","components/PlayerFeedback.jsx","components/RemainingAttempts.jsx","components/RemainingAttemptsText.jsx","components/AddressColumn.jsx","components/Line.jsx","components/gameParameters.js","components/SymbolColumn.jsx","components/ColumnContainer.jsx","components/Game.jsx","components/Welcome.jsx","App.js","serviceWorker.js","index.js"],"names":["CurrentSelection","props","currentSelection","PlayerFeedback","results","feedbackMessages","map","message","i","key","className","slice","Math","max","length","RemainingAttempts","attempts","Array","from","numAttempts","_","RemainingAttemptsText","AddressColumn","addressLines","addresses","address","toString","padStart","Line","symbols","lineSymbols","symbol","idx","highlightedSymbols","onMouseEnter","onMouseLeave","onClick","words","miscSymbols","SymbolColumn","lines","renderLine","lineIdx","this","symbolSubArray","symbolIdx","React","Component","ColumnContainer","join","highlightStates","Game","selectWords","state","password","symbolArray","fillSymbolArray","symbolHighlightState","symbolsPerLine","fill","isGameWon","tries","generateAddresses","usedBracketPairs","columns","renderColumns","symbolsPerColumn","floor","gameParameters","symbolSubArrays","highlightStateSubArrays","addressSubArrays","colClassNames","columnIdx","handleMouseEnter","handleMouseLeave","handleClick","symbolArrayIdx","getSymbolArrayIdx","isWord","wordIdx","isBracketPair","bracketStart","bracketEnd","checkGuess","usedBrackets","push","setState","giveReward","pushFeedbackMessage","wordStartIdx","dudIndices","forEach","word","dudIndex","random","splice","dudStartIndex","startIndex","messages","numMatches","gameWon","wordSubset","shuffle","indices","generateWordStartIndices","count","queue","start","end","range","shift","rndIdx","characters","symbolArr","split","j","startingAddress","generateStartingAddress","ceil","indexOf","endOfLineIdx","openBracket","correspondingCloseBracket","closeBracketIdx","rewardType","resetTries","removeDud","guess","accessMessage","compareWithPassword","checkGameWon","decreaseTries","guessArr","passwordArr","array","temp","randIdx","current","Welcome","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.99e472e2.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nfunction CurrentSelection(props){\r\n    return <p>&gt;{props.currentSelection}</p>\r\n}\r\n\r\nexport default CurrentSelection;","import React from 'react';\r\nimport CurrentSelection from \"./CurrentSelection\";\r\n\r\n// We want to give feedback that informs the player about the result of clicking \r\n// on a symbol\r\n    // That symbol could be just a symbol\r\n    // It could be part of a word\r\n    // It could be part of a set of brackets\r\n        // This has two possible outcomes\r\n// Each outcome generates a message to the player (stored in this.state.feedback) \r\n// This component is responsible for showing the most recent feedback\r\n// So essentially the only responsibility of this component is to take an array of React components \r\n// and show the 3 most recent components in an ordered list\r\n\r\nfunction PlayerFeedback(props){\r\n    const results = props.feedbackMessages.map((message, i)=>{\r\n        return (<li key = {i}>{message}</li>)\r\n    })\r\n    \r\n    return (<div className=\"feedback-column\">\r\n                <div className = \"feedback-grid\">\r\n                    <ol className = \"previous-selection\">{results.slice(Math.max(results.length - 3, 0))}</ol>\r\n                    <CurrentSelection className = \"current-selection\" currentSelection = {props.currentSelection}/>\r\n                </div>\r\n            </div>);\r\n}\r\n\r\nexport default PlayerFeedback;\r\n","import React from 'react';\r\n\r\nfunction RemainingAttempts(props){\r\n    const attempts =  Array.from({length:props.numAttempts}, \r\n                                    (_, i) =><span className=\"attempt-bullet\">__</span>);\r\n    \r\n    return (<p className = \"remaining-attempts\">{attempts}</p>)\r\n}\r\n\r\nexport default RemainingAttempts","import React from 'react'\r\n\r\nfunction RemainingAttemptsText(props){\r\n    return (<p className = \"remaining-attempts-text\">Attempts remaining:</p>)\r\n}\r\n\r\nexport default RemainingAttemptsText;","import React from 'react';\r\n\r\n// Gets an array of addresses\r\nfunction AddressColumn(props){\r\n    const addressLines = props.addresses.map((address)=>{\r\n        return <p>0x{address.toString(16).padStart(4, '0')}</p>\r\n    })\r\n\r\n    return (<div className=\"address-column\">{addressLines}</div>);\r\n}\r\n\r\nexport default AddressColumn;","import React from 'react';\r\n\r\nfunction Line(props){\r\n    const symbols = props.lineSymbols.map((symbol, idx)=>{\r\n        return (<span \r\n                        className = {props.highlightedSymbols[idx]}\r\n                        onMouseEnter= {()=>props.onMouseEnter(idx)}\r\n                        onMouseLeave={()=>props.onMouseLeave()}\r\n                        onClick={()=>props.onClick(idx)}>{symbol}\r\n                </span>) \r\n    })\r\n    return (\r\n        <p>{symbols}</p>\r\n    )\r\n}\r\n\r\nexport default Line;","//TODO Currently hard coding parameters.\r\n// wordLength will depend on difficulty\r\n// read miscSymbols and words from json\r\nexport const numWords = 10;\r\nexport const wordLength = 7;\r\nexport const wordSpacing= 2; // Minimum spacing between words\r\nexport const words= [\"dangers\", \"sending\", \"central\", \"hunters\", \"resides\", \"believe\", \"venture\", \"pattern\", \"discard\", \"mention\", \"cutters\", \"canteen\", \"beliefs\", \"banning\", \"minigun\", \"cistern\"];\r\nexport const miscSymbols = [',','.','!','@','#','$','%','&','(',')','{','}','[',']','<','>','?','\"',\"'\", '/', '|'];\r\nexport const symbolsPerLine= 12;\r\nexport const linesPerColumn = 16;\r\nexport const numColumns = 2;\r\nexport const symbolArrayLength= symbolsPerLine*linesPerColumn*numColumns;\r\nexport const initialTries = 4;\r\nexport const rewardSplit = 0.25;","/*Represents one column of symbols on the Screen*/\r\nimport React from 'react';\r\nimport Line from './Line.jsx'\r\n\r\nimport * as gameParameters from './gameParameters.js'\r\n\r\nclass SymbolColumn extends React.Component{\r\n    render(){\r\n        // See this in case you forget how the below line works\r\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#using_arrow_functions_and_array.from\r\n        const lines = Array.from({length:gameParameters.linesPerColumn},\r\n                                     (_, i) => this.renderLine(i));\r\n        return (\r\n            <div className=\"symbol-column\" >{lines}</div>\r\n        )\r\n    }\r\n\r\n    renderLine(lineIdx){\r\n        const symbols = this.props.symbolSubArray.slice(lineIdx*gameParameters.symbolsPerLine, lineIdx*gameParameters.symbolsPerLine + gameParameters.symbolsPerLine)\r\n        const highlightedSymbols = this.props.highlightedSymbols.slice(lineIdx*gameParameters.symbolsPerLine, lineIdx*gameParameters.symbolsPerLine + gameParameters.symbolsPerLine)\r\n        return (<Line  lineSymbols = {symbols}\r\n                        highlightedSymbols = {highlightedSymbols}\r\n                        onMouseEnter ={(symbolIdx) => this.props.onMouseEnter(lineIdx, symbolIdx)}\r\n                        onMouseLeave = {()=>this.props.onMouseLeave()}\r\n                        onClick= {(symbolIdx) => this.props.onClick(lineIdx, symbolIdx)}>\r\n                </Line>)\r\n    }\r\n}\r\n\r\nexport default SymbolColumn;","import React from 'react';\r\nimport AddressColumn from './AddressColumn';\r\nimport SymbolColumn from './SymbolColumn'\r\n\r\n// Wrapper for Address and Symbol columns\r\n\r\nfunction ColumnContainer(props){\r\n    return(\r\n        <div className = {[\"column-container\", props.className].join(' ')}>\r\n            <AddressColumn  addresses = {props.addresses}/>\r\n            <SymbolColumn\r\n                symbolSubArray = {props.symbols} \r\n                highlightedSymbols = {props.highlightStates}\r\n                onMouseEnter={(lineIdx, symbolIdx)=>props.onMouseEnter(lineIdx, symbolIdx)}\r\n                onMouseLeave = {()=>props.onMouseLeave()}\r\n                onClick = {(lineIdx, symbolIdx)=>props.onClick(lineIdx, symbolIdx)}>\r\n            </SymbolColumn>\r\n        </div>);\r\n}\r\n\r\nexport default ColumnContainer;","import React from 'react';\r\nimport PlayerFeedback from './PlayerFeedback';\r\nimport RemainingAttempts from './RemainingAttempts';\r\nimport RemainingAttemptsText from './RemainingAttemptsText';\r\nimport ColumnContainer from './ColumnContainer';\r\n\r\nimport * as gameParameters from './gameParameters.js'\r\n\r\n\r\nclass Game extends React.Component{\r\n    constructor(props){\r\n        super(props);\r\n        let words = this.selectWords();\r\n\r\n        this.state = {\r\n            words: words,\r\n            password: words[0]._, // Choose one word as the password. The list is in random order so we can just take the first\r\n            //TODO: Maybe put the symbols and their highlight state into a single object?\r\n            symbolArray: this.fillSymbolArray(words),\r\n            symbolHighlightState: Array(gameParameters.symbolArrayLength).fill(\"\"),\r\n            feedbackMessages: [],\r\n            isGameWon: false,\r\n            tries: gameParameters.initialTries,\r\n            addresses: this.generateAddresses(),\r\n            usedBracketPairs: [],\r\n            currentSelection: \"|\",\r\n        };\r\n    }\r\n\r\n    render(){\r\n        const columns = this.renderColumns();\r\n        //TODO: The components have their own class names, but since those class names are responsible\r\n        // for the positioning the components in the grid, maybe the class names should be set here\r\n        return (<div className=\"game-board\">\r\n                    <RemainingAttemptsText/>\r\n                    <RemainingAttempts numAttempts = {this.state.tries}/>\r\n                    {columns}\r\n                    <PlayerFeedback feedbackMessages = {this.state.feedbackMessages} currentSelection = {this.state.currentSelection}/>\r\n                </div>);\r\n    }\r\n\r\n    /*---Render Functions---*/\r\n\r\n    //TODO: Possibly make another component that wraps around the two column containers?\r\n    renderColumns(){\r\n        // Distributes the symbols among the columns\r\n        const symbolsPerColumn = Math.floor(gameParameters.symbolArrayLength/gameParameters.numColumns);\r\n\r\n        const symbolSubArrays = Array.from({length:gameParameters.numColumns},\r\n            (_, i) => this.state.symbolArray.slice(i*symbolsPerColumn, (i+1)*symbolsPerColumn));\r\n\r\n        // Distributes the corresponding symbol highlight state\r\n        const highlightStateSubArrays = Array.from({length:gameParameters.numColumns},\r\n            (_,i) => this.state.symbolHighlightState.slice(i*symbolsPerColumn, (i+1)*symbolsPerColumn));\r\n\r\n        // Distribute memoory address for lines\r\n        const addressSubArrays = Array.from({length: gameParameters.numColumns},\r\n            (_, i) => this.state.addresses.slice(i*gameParameters.linesPerColumn, (i+1)*gameParameters.linesPerColumn));\r\n\r\n        // Class names for cols\r\n        const colClassNames = [\"first-column-container\", \"second-column-container\"];\r\n\r\n        const columns = Array.from({length:gameParameters.numColumns},\r\n            (_, columnIdx) => <ColumnContainer\r\n                        className = {colClassNames[columnIdx]}\r\n                        addresses = {addressSubArrays[columnIdx]}\r\n                        symbols = {symbolSubArrays[columnIdx]} \r\n                        highlightStates = {highlightStateSubArrays[columnIdx]}\r\n                        onMouseEnter={(lineIdx, symbolIdx)=>this.handleMouseEnter(columnIdx, lineIdx, symbolIdx)}\r\n                        onMouseLeave = {()=>this.handleMouseLeave()}\r\n                        onClick = {(lineIdx, symbolIdx)=>this.handleClick(columnIdx, lineIdx, symbolIdx)}\r\n                        />);\r\n\r\n        return columns;\r\n    }\r\n\r\n    /*---Event Handlers---*/\r\n\r\n    handleClick(columnIdx, lineIdx, symbolIdx){\r\n        if(this.state.tries > 0 && !this.state.isGameWon){\r\n            const symbolArrayIdx = this.getSymbolArrayIdx(columnIdx, lineIdx, symbolIdx);\r\n            const {_, wordIdx} = this.isWord(symbolArrayIdx);\r\n            const {bracketStart, bracketEnd} = this.isBracketPair(symbolArrayIdx);\r\n\r\n            if(wordIdx !== -1){\r\n               this.checkGuess(this.state.words[wordIdx]._);\r\n            }\r\n            else if(bracketStart !== -1){\r\n                // Add to list of used bracket pairs, so that the player can't infinitely get rewards\r\n                const usedBrackets = this.state.usedBracketPairs.slice();\r\n                    usedBrackets.push(symbolArrayIdx);\r\n                    this.setState({\r\n                        usedBracketPairs: usedBrackets,\r\n                    });\r\n                this.giveReward(this.state.symbolArray.slice(bracketStart, bracketEnd));\r\n            }\r\n            else{\r\n                this.pushFeedbackMessage(<div>\r\n                                            <p>&gt;{this.state.symbolArray[symbolArrayIdx]}</p>\r\n                                            <p>&gt; Error</p>\r\n                                        </div>);\r\n            }\r\n        }\r\n    }\r\n\r\n    handleMouseEnter(columnIdx, lineIdx, symbolIdx){\r\n        if(this.state.tries > 0 && !this.state.isGameWon){\r\n            // Need to first clear highlights and then set specific highlights in a callback to deal with JS asynchrony nonsense\r\n            this.setState({symbolHighlightState:Array(gameParameters.symbolArrayLength).fill(\"symbol\")}, ()=>{\r\n                const symbolArrayIdx = this.getSymbolArrayIdx(columnIdx, lineIdx, symbolIdx);\r\n                let highlightedSymbols = this.state.symbolHighlightState.slice();\r\n\r\n                // If the symbol is part of a word all the symbols of the word need to be highlighted\r\n                const {wordStartIdx, wordIdx} = this.isWord(symbolArrayIdx);\r\n                const {bracketStart, bracketEnd} = this.isBracketPair(symbolArrayIdx);\r\n                let currentSelection = [];\r\n                if(wordIdx !== -1){\r\n                    currentSelection = this.state.symbolArray.slice(wordStartIdx, wordStartIdx + gameParameters.wordLength);\r\n                    for(let i = wordStartIdx; i<wordStartIdx + gameParameters.wordLength; i++){\r\n                        highlightedSymbols[i]=\"highlighted-symbol\";\r\n                    }\r\n                }\r\n                else if(bracketStart !== -1){\r\n                    currentSelection = this.state.symbolArray.slice(bracketStart, bracketEnd);\r\n                    for(let i = bracketStart; i<bracketEnd;i++){\r\n                        highlightedSymbols[i]=\"highlighted-symbol\";\r\n                    }\r\n                }\r\n                else{\r\n                    currentSelection = this.state.symbolArray.slice(symbolArrayIdx, symbolArrayIdx+1);\r\n                    highlightedSymbols[symbolArrayIdx] = \"highlighted-symbol\";\r\n                }\r\n                \r\n                this.setState({\r\n                    symbolHighlightState:highlightedSymbols,\r\n                    currentSelection: currentSelection,\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    handleMouseLeave(){\r\n        const highlightedSymbols = Array(gameParameters.symbolArrayLength).fill(\"\");\r\n        this.setState({\r\n            symbolHighlightState: highlightedSymbols,\r\n            currentSelection: \"|\",\r\n        })\r\n    }\r\n    \r\n    /*---Game state functions---*/\r\n    decreaseTries(){\r\n        const tries = this.state.tries -1;\r\n        this.setState({\r\n            tries : tries,\r\n        })\r\n    }\r\n\r\n    resetTries(){\r\n        this.setState({\r\n            tries:gameParameters.initialTries,\r\n        });\r\n\r\n    }\r\n\r\n    removeDud(){\r\n        // Get indices for all words that are not the password\r\n        let dudIndices = [];\r\n        const words = this.state.words.slice();\r\n        words.forEach((word, i) =>{\r\n            if(word._ !== this.state.password){\r\n                dudIndices.push(i);\r\n            }\r\n        })\r\n\r\n        // Select dud at random\r\n        const dudIndex = dudIndices[Math.floor(Math.random()*dudIndices.length)];\r\n        words.splice(dudIndex, 1); // remove dud from the list of words that are to be displayed\r\n\r\n        // Need to replace the symbols of the dud word with blanks\r\n        const dudStartIndex = this.state.words[dudIndex].startIndex;\r\n        const symbolArray = this.state.symbolArray.slice()\r\n        for(let i = dudStartIndex; i< dudStartIndex+gameParameters.wordLength; i++){\r\n            symbolArray[i] = '.';\r\n        }\r\n\r\n        this.setState({\r\n            symbolArray: symbolArray,\r\n            words: words,\r\n        })\r\n    }\r\n\r\n    pushFeedbackMessage(message){\r\n        const messages = this.state.feedbackMessages.slice();\r\n        messages.push(message);\r\n        this.setState({\r\n            feedbackMessages: messages,\r\n        })\r\n    }\r\n\r\n    checkGameWon(numMatches){\r\n        const gameWon = (numMatches === gameParameters.wordLength);\r\n        \r\n        this.setState({\r\n            isGameWon:gameWon,\r\n        })\r\n\r\n        return gameWon;\r\n    }\r\n\r\n    /*---Initialiser functions: sets initial game state---*/\r\n    //Chooses 10 words from the list of 16 in gameParameters\r\n    selectWords(){\r\n        // Take a random subset of 10 words\r\n        let wordSubset = gameParameters.words.slice();\r\n        this.shuffle(wordSubset);\r\n        wordSubset = wordSubset.slice(0,gameParameters.numWords);\r\n        \r\n        // map to an array of objects with word and index properties\r\n        const words =  wordSubset.map(word => \r\n            ({\r\n                _: word,    // doesn't really make sense to have a property called word in an object also called word\r\n                            // and it doesn't make sense to call the object anything else\r\n                startIndex: null\r\n             }));\r\n\r\n        // assign random starting indices for the words\r\n        const indices = this.generateWordStartIndices();\r\n        words.forEach((word, i) => word.startIndex = indices[i]);\r\n\r\n        return words;\r\n    };\r\n\r\n    // Generates random indices for an array, ensuring there is room between indices for a word to fit\r\n    generateWordStartIndices(){\r\n        let indices = Array(gameParameters.numWords);\r\n        let count = 0;\r\n\r\n        let queue = [];\r\n        queue.push({start:0, end:(gameParameters.symbolArrayLength-gameParameters.wordLength)});\r\n\r\n        while(count < gameParameters.numWords){\r\n            let range = queue.shift();\r\n            \r\n            if((range.end - range.start) > gameParameters.wordLength){\r\n                let rndIdx = Math.floor(range.start + Math.random()*(range.end-range.start));\r\n                indices[count++] = rndIdx;\r\n                queue.push({start:range.start, end:rndIdx - gameParameters.wordLength});\r\n                queue.push({start: rndIdx + gameParameters.wordLength + 1, end:range.end});\r\n            }\r\n        }\r\n\r\n        return indices;\r\n    }\r\n\r\n    // Fills the symbol array with words starting at the corresponding starting index \r\n    // and fills the remaining space with random symbols\r\n    fillSymbolArray(words){\r\n        let symbolArr = Array(gameParameters.symbolArrayLength).fill(null);\r\n        let word, start, characters;\r\n        // Enter the words at the corresponding starting index\r\n        for(let i = 0; i<words.length; i++){\r\n            word = words[i];\r\n            start = word.startIndex;\r\n            characters = word._.split('');\r\n            for(let j =0; j<gameParameters.wordLength; j++){\r\n                symbolArr[start+j] = characters[j];\r\n            }\r\n        }\r\n\r\n        // Fill remaining spaces with random misc symbols ...\r\n        for(let i = 0; i<gameParameters.symbolArrayLength; i++){\r\n            if(symbolArr[i] == null){\r\n                symbolArr[i] = gameParameters.miscSymbols[Math.floor(Math.random()*gameParameters.miscSymbols.length)];\r\n            }\r\n        }\r\n\r\n        return symbolArr;\r\n    }\r\n\r\n    // Generates a list of memory addresses for the decorative address column\r\n    generateAddresses(){\r\n        const byteSize = 8; //TODO: define bytesize elsewhere?\r\n        let addresses = Array(gameParameters.linesPerColumn*gameParameters.numColumns);\r\n\r\n        const startingAddress = this.generateStartingAddress();\r\n\r\n        for(let i=0; i<addresses.length; i++){\r\n            addresses[i] = startingAddress+(i*byteSize);\r\n        }\r\n\r\n        return addresses;\r\n    }\r\n\r\n    // Generates a random memory address\r\n    // The address space goes from 0x0000 through to 0xFFFF\r\n    // Memory is byte addressable\r\n    generateStartingAddress(){\r\n        const byteSize = 8;\r\n        const maxAddress = 0xFFFF - (gameParameters.linesPerColumn*gameParameters.numColumns*byteSize)+byteSize;\r\n\r\n        let startingAddress = Math.ceil(Math.random()*maxAddress);\r\n\r\n        const remainder = startingAddress%byteSize;\r\n        startingAddress = startingAddress - remainder; //Removing the remainder ensures the address is a multiple of 8\r\n\r\n        return startingAddress;\r\n    }\r\n\r\n    /*---Helper functions---*/\r\n\r\n    // this.state.symbolArray is distributed among the columns and lines, \r\n    // this uses the indices of the column, line and symbol within the line to calculate\r\n    // the index of the symbol in this.state.symbolArray\r\n    getSymbolArrayIdx(columnIdx, lineIdx, symbolIdx){\r\n        // Calculate index of the symbol in the symbol array\r\n        const symbolArrayIdx = Math.floor(gameParameters.symbolArrayLength/gameParameters.numColumns)*columnIdx + gameParameters.symbolsPerLine*lineIdx + symbolIdx;\r\n        return symbolArrayIdx;\r\n    }\r\n\r\n    // Checks if the selected symbol belongs to a word\r\n    // if the symbol belongs to a word, returns the index of the word in gameParameters.words\r\n    // returns -1 otherwise;\r\n    isWord(symbolArrayIdx){\r\n        let wordStartIdx = -1;\r\n        let wordIdx = -1;\r\n        this.state.words.forEach((word, i) =>{\r\n            if(symbolArrayIdx >= word.startIndex && symbolArrayIdx < word.startIndex + gameParameters.wordLength){\r\n                wordStartIdx = word.startIndex;\r\n                wordIdx = i;\r\n            }\r\n        });\r\n\r\n        return {wordStartIdx, wordIdx};\r\n    }\r\n    \r\n    // Checks if the selected symbol is the opening bracket of a pair of brackets on the same line.\r\n    isBracketPair(symbolArrayIdx){\r\n        if(this.state.usedBracketPairs.indexOf(symbolArrayIdx) === -1){\r\n            const openBrackets  = ['<', '(', '{', '['];\r\n            const closeBrackets = ['>', ')', '}', ']'];\r\n\r\n            const endOfLineIdx = symbolArrayIdx + (gameParameters.symbolsPerLine - (symbolArrayIdx % gameParameters.symbolsPerLine)); // Finds where the current line ends\r\n            const openBracket = openBrackets.indexOf(this.state.symbolArray[symbolArrayIdx]); // Check if the clicked symbol appears in the list of open brackets\r\n\r\n            if(openBracket !== -1 && (endOfLineIdx >symbolArrayIdx)){ // user clicked on an open bracket\r\n                // Check if the corresponding closing bracket appears in the remaining symbols in the line\r\n                const correspondingCloseBracket = closeBrackets[openBracket];\r\n                const remainingSymbolsInLine = this.state.symbolArray.slice(symbolArrayIdx, endOfLineIdx);\r\n                const closeBracketIdx = remainingSymbolsInLine.indexOf(correspondingCloseBracket);\r\n                if(closeBracketIdx !== -1){\r\n                    return {bracketStart: symbolArrayIdx, bracketEnd: (symbolArrayIdx + closeBracketIdx + 1)};                \r\n                }\r\n            }\r\n        }\r\n        return {bracketStart:-1, bracketEnd: -1};\r\n    }\r\n\r\n    // Randomly chooses between resetting the number of remaining tries and removing a dud\r\n    // When the player clicks on a pair of brackets on the same line\r\n    giveReward(symbols){\r\n        const rnd = Math.random();\r\n        let rewardType;\r\n        if(rnd < gameParameters.rewardSplit){\r\n            rewardType = \"Tries Reset.\"\r\n            this.resetTries();\r\n        }\r\n        else{\r\n            rewardType = \"Dud Removed.\"\r\n            this.removeDud();\r\n        }\r\n\r\n        const message =(<div>\r\n                            <p>&gt;{symbols}</p>\r\n                            <p>&gt;{rewardType}</p>\r\n                        </div>)\r\n        this.pushFeedbackMessage(message);\r\n    }\r\n\r\n    checkGuess(guess){\r\n        const numMatches = this.compareWithPassword(guess);\r\n        const gameWon = this.checkGameWon(numMatches);\r\n        this.decreaseTries();\r\n\r\n        let accessMessage;\r\n        if(gameWon){\r\n           accessMessage = \"Entry Granted\"\r\n        }\r\n        else{\r\n            accessMessage = \"Entry Denied\"\r\n        }    \r\n        this.pushFeedbackMessage(<div>\r\n                                    <p>&gt;{guess}</p>\r\n                                    <p>&gt;{accessMessage}</p>\r\n                                    <p>&gt;Likeness = {numMatches}</p>\r\n                                </div>);\r\n    }\r\n\r\n    compareWithPassword(guess){\r\n        const guessArr = guess.split('');\r\n        const passwordArr = this.state.password.split('');\r\n        \r\n        let numMatches = 0;\r\n        passwordArr.forEach((symbol, i)=>{\r\n            if(symbol === guessArr[i]) numMatches++;\r\n        });\r\n\r\n        return numMatches;\r\n    }\r\n\r\n    // Recursive nature of generateWordIndices means that the the i+1 index will be before the i th index \r\n    // and the i+2 index will be after the first (assuming there is room). \r\n    // Shuffling the indices will make it more randomised \r\n    shuffle(array){\r\n        let current = array.length;\r\n        let temp, randIdx;\r\n\r\n        while(current !== 0){\r\n            // Choose a random element\r\n            randIdx = Math.floor(Math.random()*current);\r\n            current -=1;\r\n\r\n            // swap with current element\r\n            temp = array[current];\r\n            array[current] = array[randIdx];\r\n            array[randIdx] = temp;\r\n        }\r\n    }\r\n}\r\n\r\nexport default Game;","import React from 'react';\r\n\r\nfunction Welcome(){\r\n    return(<div className=\"welcome-message\">\r\n        <p>Welcome to ROBCO Industries (TM) TermLink</p>\r\n        <p>Password Required</p>\r\n    </div>)\r\n}\r\n\r\nexport default Welcome;","import React from 'react';\r\nimport './App.css';\r\n\r\nimport Game from './components/Game';\r\nimport Welcome from './components/Welcome';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Welcome/>\r\n      <Game/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}